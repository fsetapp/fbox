<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Fbox basic</title>
</head>
<style>
  html {
    font-family: ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Helvetica Neue, Arial, Noto Sans, sans-serif, Apple Color Emoji, Segoe UI Emoji, Segoe UI Symbol, Noto Color Emoji;
  }

  kbd {
    border: 1px solid gray;
    padding: .25rem;
    border-radius: .25rem;
  }

  dfn {
    font-style: normal;
  }

  ul {
    padding: 0;
    list-style: none;
  }

  @keyframes fadein {
    from {
      opacity: 0;
    }

    to {
      opacity: 1;
    }
  }

  [role="tree"] {
    min-width: 374px;
    /* text-sm */
    font-size: .875rem;
    line-height: 1.25rem;
    background-color: rgb(20, 20, 20);
    /* text-gray-300 */
    color: rgba(209, 213, 219, 1);
  }

  [role="treeitem"] {
    border: 1px solid transparent;
  }

  [role="treeitem"][aria-selected="true"] {
    border: 1px dashed blue;
  }

  [role="treeitem"][aria-selected="true"]:focus {
    border: 1px solid blue;
  }

  [role="treeitem"].item-cutting {
    border: 1px solid orange;
  }

  [role="treeitem"].item-pasted {
    animation: fadein;
    animation-duration: .25s;
  }


  .file {
    display: flex;
  }

  .folder .h {
    display: flex;
    width: 100%;
  }

  [role="group"][data-group="keyed"]>[role="treeitem"]>.k {
    color: inherit;
  }

  [role="group"][data-group="indexed"]>[role="treeitem"]>.k,
  [role="group"][data-group="indexed"]>[role="treeitem"]>.h>.k {
    /*text-gray-500*/
    color: rgba(107, 114, 128, 1);
  }

  .s {
    margin: 0 .5rem;
    /*text-gray-500*/
    color: rgba(107, 114, 128, 1);

  }

  .t {
    /*text-pink-400*/
    color: rgba(244, 114, 182, 1);
  }

  textarea {
    font-family: inherit;
    font-size: inherit;
    line-height: inherit;
    height: inherit;
    margin: 0;
    padding: 0 .5rem;
    border: 0;
    background-color: antiquewhite;
  }

  textarea.no-resize {
    display: block;
    resize: none;
  }
</style>
<script type="module">
  import { render, html } from "https://cdn.skypack.dev/pin/uhtml@v2.2.2-NCNWbAlfOH9s1rfcepA9/min/uhtml.js"

  const RECORD = "record"
  const LIST = "list"
  const TUPLE = "tuple"
  const STRING = "string"
  const NUMBER = "number"
  const INTEGER = "integer"
  const BOOLEAN = "boolean"
  const NULL = "null"
  const UNION = "union"
  const ANY = "any"
  const REF = "ref"
  const VALUE = "value"
  const CONTAINER_TYPES = [RECORD, TUPLE, LIST, UNION]

  const anySch = () => ({ type: ANY })
  const stringSch = () => ({ type: STRING })
  const boolSch = () => ({ type: BOOLEAN })
  const numberSch = () => ({ type: NUMBER })
  const nullSch = () => ({ type: NULL })
  const recordSch = () => ({ type: RECORD, fields: {}, order: [] })
  const listSch = () => ({ type: LIST, sch: anySch() })
  const tupleSch = () => ({ type: TUPLE, schs: [stringSch(), boolSch(), numberSch()] })
  const unionSch = () => ({ type: UNION, schs: [nullSch(), recordSch(), numberSch()] })
  const schs = [anySch, stringSch, boolSch, numberSch, nullSch, recordSch, listSch, tupleSch, unionSch]

  var store = recordSch()
  const clone = (obj) => JSON.parse(JSON.stringify(obj))

  const walk = (sch, f, meta = {}) => {
    meta.path = meta.path || ""
    meta.level = meta.level || 0

    switch (true) {
      case [RECORD].includes(sch.type):
        for (let [k, sch_] of Object.entries(sch.fields)) {
          let nextMeta = { path: `${meta.path}[${k}]`, level: meta.level + 1 }
          sch.fields[k] = walk(sch_, f, nextMeta)
        }
        break
      case [TUPLE, UNION].includes(sch.type):
        sch.schs.forEach((sch_, i) => {
          let nextMeta = { path: `${meta.path}[][${i}]`, level: meta.level + 1 }
          sch.schs[i] = walk(sch_, f, nextMeta)
        })
        break
      case [LIST].includes(sch.type):
        let nextMeta = { path: `${meta.path}[][0]`, level: meta.level + 1 }
        sch.sch = walk(sch.sch, f, nextMeta)
        break
      default:
        sch
    }

    return f(sch, meta)
  }

  const popSchs = (schema, path, indices) => {
    let result = { original: clone(schema), popped: [] }
    let descIndices = indices.sort((a, b) => b - a)

    walk(schema, (sch_, meta) => {
      if (meta.path != path) return sch_
      else {
        switch (sch_.type) {
          case RECORD:
            let ikeys = descIndices.map(i => [i, sch_.order[i]]).filter(([i, k]) => k)

            for (let [i, k] of ikeys) {
              result.popped.unshift({ k: k, sch: sch_.fields[k], index: i })
              delete sch_.fields[k]
            }
            for (let i of descIndices) sch_.order.splice(i, 1)

            break
          case LIST:
            break
          case TUPLE:
            for (let i of descIndices)
              result.popped.unshift({ k: i, sch: sch_.schs.splice(i, 1)[0], index: i })
            break
          case UNION:
            for (let i of descIndices)
              result.popped.unshift({ k: i, sch: sch_.schs.splice(i, 1)[0], index: i })
            break
          default:
            sch_
        }
        return sch_
      }
    })

    return result
  }

  const putSchs = (schema, path, rawSchs) => {
    let result = { original: clone(schema), inserted: [] }
    let ascRawSchs = rawSchs.sort((a, b) => a.index - b.index)

    walk(schema, (sch_, meta) => {
      if (meta.path != path) return sch_
      else {
        switch (sch_.type) {
          case RECORD:
            for (let { k, sch, index } of ascRawSchs) {
              k = k == 0 ? "0" : k
              k = k || `key_${Math.floor(Date.now() / 100)}`
              while (sch_.fields[k]) k = `${k} –`

              sch_.fields[k] = sch()
              sch_.order.splice(index, 0, k)
              result.inserted.push({ k: k, sch: sch_.fields[k], index: index })
            }

            break
          case LIST:
            break
          case TUPLE:
            for (let { k, sch, index } of ascRawSchs) {
              sch_.schs.splice(index, 0, sch())
              result.inserted.push({ k: k, sch: sch_.schs[index], index: index })
            }
            break
          case UNION:
            for (let { k, sch, index } of ascRawSchs) {
              sch_.schs.splice(index, 0, sch())
              result.inserted.push({ k: k, sch: sch_.schs[index], index: index })
            }
          default:
            sch_
        }
        return sch_
      }
    })
    return result
  }

  const moveSchs = (store, { dstPath, startIndex = 0 }, selectedPerParent) => {
    const pinDst = (store, dstPath, pin) =>
      getAndUpdateSch(store, (a, m) => m.path == dstPath, (a, m) => { a._pinId = pin; return a })

    const getPinedDst = (store, pin) =>
      getAndUpdateSch(store, (a, m) => a._pinId == pin, (a, m) => { a._pinned = m; return a })


    const srcPaths = filterMostOuters(Object.keys(selectedPerParent))
    let moved = {}

    for (let srcPath of srcPaths) {
      let selectedItems = selectedPerParent[srcPath]
      let isDstSubtree = selectedItems.filter(c => dstPath.startsWith(c.id)).length != 0
      const newK = (index) => selectedItems.filter(c => c.index == index)[0]?.newK

      if (!isDstSubtree) {
        let pin = Symbol(srcPath)
        pinDst(store, dstPath, pin)

        let result = popSchs(store, srcPath, selectedItems.map(c => c.index))
        let rawSchs = result.popped.map(({ k, sch, index }, i) => {
          return { k: newK(index) || k, sch: () => sch, index: startIndex + i }
        })

        let dst = getPinedDst(store, pin)
        let result_ = putSchs(store, dst._pinned.path, rawSchs)

        moved[dst._pinned.path] = result_.inserted
      }
    }

    return moved
  }

  const getSch = (currentNode, path) =>
    getSchBy(currentNode, (a, m) => m.path == path)

  const getSchBy = (currentNode, fget) =>
    getAndUpdateSch(currentNode, fget, (a, m) => a)

  const getAndUpdateSch = (currentNode, fget, fupdate) => {
    let foundSch
    walk(currentNode, (sch_, meta) => {
      if (fget(sch_, meta)) return foundSch = fupdate(sch_, meta)
      else return sch_
    })
    return foundSch && { ...foundSch }
  }

  const renderRoot = (sch) =>
    viewMain({ sch: sch, ui: { level: 1, tab: 1.5 }, path: "", key: "root" })

  const viewMain = (assigns) =>
    render(document.body, html`
      <h3>Add</h3>
      <p>Press <kbd>shift</kbd> + <kbd>+</kbd> to add random schema to container types (record | union | tuple)</p>
      <h3>Select</h3>
      <p>Press <kbd>ArrowUp</kbd> / <kbd>ArrowUp</kbd> to select schema</p>
      <p>Press <kbd>shift</kbd> + <kbd>ArrowUp</kbd> / <kbd>ArrowUp</kbd> to mutiple select schema</p>
      <h3>Delete</h3>
      <p>Press <kbd>Delete</kbd> to delete selected schema</p>
      <h3>Move</h3>
      <p>Press <kbd>cmd</kbd> + <kbd>x</kbd> to cut selected schema</p>
      <p>Press <kbd>cmd</kbd> + <kbd>v</kbd> to paste schema from (cmd + x) command</p>
      <h3>Rename key</h3>
      <p>Press <kbd>Enter</kbd> on a selected schema to enable key editting</p>
      <p>Press <kbd>Enter</kbd> within a text input to submit a changed key</p>

      <div style="display: flex;">
        <section style="width: 50%">
          <ul role="tree" aria-multiselectable="true">
            ${viewModel(assigns)}
          </ul>
        </section>
        <section style="width: 50%">
          <pre><code>${JSON.stringify(store, null, '  ')}</code></pre>
        </section>
      </div>
    `)

  const viewModel = (assigns) =>
    CONTAINER_TYPES.includes(assigns.sch.type) ? viewFolder(assigns) : viewFile(assigns)

  const viewFolder = (assigns) =>
    html.for(assigns.sch, assigns.path)`
    <li id="${assigns.path}" .key=${assigns.key} class="folder" role="treeitem" aria-level="${assigns.ui.level}" aria-selected="false" tabindex="-1">
      <dfn class="h">
        ${viewKey({ ...assigns, key: wordBreakHtml(assigns.key) })}
        ${viewType(assigns)}
      </dfn>
      <ul data-group="${keyedOrIndexed(assigns.sch)}" role="group">
        ${viewItself(assigns)}
      </ul>
    </li>`

  const viewFile = (assigns) =>
    html.for(assigns.sch, assigns.path)`
    <li id="${assigns.path}" .key=${assigns.key} class="file" role="treeitem" aria-level="${assigns.ui.level}" aria-selected="false" tabindex="-1">
      ${viewKey({ ...assigns, key: wordBreakHtml(assigns.key) })}
      ${viewType(assigns)}
    </li>`

  const viewItself = (assigns) => {
    switch (true) {
      case [RECORD].includes(assigns.sch.type):
        return viewKeyed(assigns)
        break
      case [TUPLE].includes(assigns.sch.type):
        return viewIndexed(assigns)
        break
      case [LIST].includes(assigns.sch.type):
        return viewSingled(assigns)
        break
      case [UNION].includes(assigns.sch.type):
        return viewNonKeyed(assigns)
        break
      default:
        return html``
    }
  }

  const viewKeyed = (assigns) =>
    assigns.sch.order.map(k =>
      viewModel({
        key: k,
        sch: assigns.sch.fields[k],
        parent: { type: assigns.sch.type, path: assigns.path },
        ui: { ...assigns.ui, level: assigns.ui.level + 1 },
        path: `${assigns.path}[${k}]`
      })
    )

  const viewIndexed = (assigns) =>
    assigns.sch.schs.map((sch, i) =>
      viewModel({
        key: i,
        sch: assigns.sch.schs[i],
        parent: { type: assigns.sch.type, path: assigns.path },
        ui: { ...assigns.ui, level: assigns.ui.level + 1 },
        path: `${assigns.path}[][${i}]`
      })
    )

  const viewSingled = (assigns) =>
    viewModel({
      key: 0,
      sch: assigns.sch.sch,
      parent: { type: assigns.sch.type, path: assigns.path },
      ui: { ...assigns.ui, level: assigns.ui.level + 1 },
      path: `${assigns.path}[][${0}]`
    })

  const viewNonKeyed = (assigns) =>
    assigns.sch.schs.map((sch, i) =>
      viewModel({
        key: "",
        sch: sch,
        parent: { type: assigns.sch.type, path: assigns.path },
        ui: { ...assigns.ui, level: assigns.ui.level + 1 },
        path: `${assigns.path}[][${i}]`
      })
    )

  const indent = (assigns) => `padding-left: ${((assigns.ui.level - 1) * 1.25) + assigns.ui.tab}rem`
  const viewKey = (assigns) => assigns.ui.level == 1 ? viewKeyRoot(assigns) : viewKeyNonRoot(assigns)
  const viewKeyRoot = (assigns) =>
    html`
    <span class="text-blue-500 mr-2" style=${indent(assigns)}>
      ${modelTypeText(assigns.sch, assigns.ui)}
    </span>
    <span class="k">${assigns.key}</span>
    <span class="s">=</span>
    `
  const viewKeyNonRoot = (assigns) => {
    switch (true) {
      case assigns.parent.type == UNION:
        return html`
          <span class="" style=${indent(assigns)}></span>
          <span class="s">|</span>
          `
        break
      case assigns.parent.type == LIST:
        return html`
          <span class="k" style=${indent(assigns)}></span>
          <span class="s">└</span>
          `
        break
      default:
        const editableKey = (assigns) =>
          (assigns.sch?.uiMode == "editKey") ?
            html`<textarea class="no-resize" spellcheck="false" maxlength="256" rows="1" autofocus data-parent-path="${assigns.parent.path}">${assigns.key}</textarea>`
            :
            html`${assigns.key}`

        return html`
          <span class="k" style=${indent(assigns)}>
            ${editableKey(assigns)}
          </span >
          <span class="s">:</span>
        `
    }
  }

  const viewType = (assigns) => assigns.level == 1 ? viewTypeRoot(assigns) : viewTypeNonRoot(assigns)
  const viewTypeRoot = (assigns) =>
    html`<span class="t" role="complementary">${typeText(assigns.sch, assigns.ui)}</span>`
  const viewTypeNonRoot = (assigns) =>
    html`<span class="t" role="complementary">${typeText(assigns.sch, assigns.ui)}</span>`

  const typeText = (sch, ui) => {
    switch (true) {
      case sch.type == RECORD && jEQ(sch.fields, {}): return "{ any }"
      case sch.type == RECORD: return `{ \xa0 }`
      case sch.type == LIST && sch.sch.type == "any": return "[ any ]"
      case sch.type == LIST: return `${typeText(sch.sch, ui)}`
      case sch.type == TUPLE: return "( \xa0 )"
      case sch.type == STRING: return "string"
      case sch.type == NUMBER: return "number"
      case sch.type == INTEGER: return "integer"
      case sch.type == BOOLEAN: return "bool"
      case sch.type == NULL: return "null"
      case sch.type == UNION: return "||"
      case sch.type == ANY: return "any"
      case sch.type == REF: return "ref"
      case sch.type == VALUE: return "value"
      default: return "please define what type ${sch} is"
    }
  }

  const wordBreakHtml = (word) => word
  const keyedOrIndexed = (sch) => {
    switch (sch.type) {
      case RECORD: return "keyed"
      case TUPLE: return "indexed"
      case UNION: return "indexed"
      default: return "none"
    }
  }

  const modelTypeText = (sch, ui) => {
    switch (true) {
      case sch.type == RECORD: return "record"; break
      case sch.type == LIST: return "list"; break
      case sch.type == TUPLE: return "tuple"; break
      case sch.type == UNION: return "union"; break
      default: return "field"
    }
  }

  const selectedGroupedByParent = (tree, opts = {}) =>
    [...tree.querySelectorAll(`${opts.ops || "[aria-selected='true']"}`)].reduce((acc, child) => {
      let parent = child.parentNode.closest("[role='treeitem']")
      if (!parent) return acc

      let parentLevel = parseInt(parent.getAttribute("aria-level"))
      let children = parent.querySelectorAll(`[aria-level='${parentLevel + 1}'][role='treeitem']`)

      child.index = [...children].indexOf(child)
      acc[parent.id] = acc[parent.id] || []
      acc[parent.id].push(child)
      return acc
    }, {})

  const deleteSelected = (tree) => {
    const indicesPerParent = selectedGroupedByParent(tree)

    for (let parentPath of Object.keys(indicesPerParent))
      popSchs(store, parentPath, indicesPerParent[parentPath].map(c => c.index))
  }

  const renameSelected = (tree, textArea) => {
    let indicesPerParent = selectedGroupedByParent(tree)
    let dstPath = textArea.dataset.parentPath

    indicesPerParent[textArea.dataset.parentPath] =
      indicesPerParent[textArea.dataset.parentPath]
        .filter(c => c.id == textArea._treeItem.id)
        .map(c => ({ id: c.id, newK: textArea.value, index: c.index }))

    let renameIndex = indicesPerParent[textArea.dataset.parentPath][0].index
    let moved = moveSchs(store, { dstPath, startIndex: renameIndex }, indicesPerParent)

    return moved[dstPath][0].k
  }

  const selectNode = (tree, currentNode, nextStepNode, opts = { focus: true }) => {
    if (nextStepNode) {
      deselectAllNode(tree, currentNode)
      selectMultiNode(nextStepNode, opts)
    }
  }
  const deselectAllNode = (tree, currentNode) => {
    [...tree.querySelectorAll("[aria-selected='true']")]
      .forEach(item => item.setAttribute("aria-selected", false))
    currentNode.tabIndex = -1
    currentNode.setAttribute("aria-selected", false)

    let _ = [...tree.querySelectorAll(".item-pasted")]
      .forEach(a => a.classList.remove("item-pasted"))
  }
  const selectMultiNode = (nextStepNode, opts = { focus: true }) => {
    if (nextStepNode) {
      nextStepNode.setAttribute("aria-selected", true)
      nextStepNode.tabIndex = 0
      opts.focus && nextStepNode.focus()
    }
  }
  const findUnselectedNode = (fstep, nextNode) => {
    do nextNode = fstep()
    while (nextNode?.getAttribute("aria-selected") == "true")
    return nextNode
  }
  const reselectNodes = (tree, nodes) => {
    for (let newDst of Object.keys(nodes)) {
      let rawSchs = nodes[newDst]

      newDst = tree.querySelector(`[id='${newDst}']`)
      let dstLevel = parseInt(newDst.getAttribute("aria-level"))
      let children = newDst.querySelectorAll(`[aria-level='${dstLevel + 1}'][role='treeitem']`)

      deselectAllNode(tree, tree._walker.currentNode)
      rawSchs.map(({ index }) => children[index]).forEach(a => {
        a.classList.add("item-pasted")
        selectMultiNode(a)
        tree._walker.currentNode = a
      })
    }
  }

  const filterMostOuters = (paths) => {
    return paths.filter(p => {
      for (let p_ of paths) {
        if (p == p_) return true
        else if (p.startsWith(p_)) return false
      }
    })
  }

  const clearClipboard = (tree) => {
    tree.querySelectorAll(".item-cutting").forEach(a => a.classList.remove("item-cutting"))
    tree._clipboard = null
  }

  const handleTextAreaKeyDown = (e, tree) => {
    let currentNode = tree._walker.currentNode
    let textArea = e.target

    switch (e.code) {
      case "Enter":
        if (!e.shiftKey) {
          textArea._treeItem = textArea.closest("[role='treeitem']")
          selectNode(tree, currentNode, textArea._treeItem, { focus: false })

          let newKey = renameSelected(tree, textArea)
          let ancestor = textArea._treeItem.parentNode.closest("[role='treeitem']")
          let renamedId = `${ancestor.id}[${newKey}]`

          getAndUpdateSch(store, (a, m) => m.path == renamedId, (a, m) => ({ ...a, uiMode: "viewKey" }))
          renderRoot(store)
          tree._walker.currentNode = tree.querySelector(`[id='${renamedId}']`)
          selectNode(tree, currentNode, tree._walker.currentNode)
        }
        break
    }
  }

  function handleTreeKeydown(e) {
    let tree = this
    let currentNode = tree._walker.currentNode

    if (e.target instanceof HTMLTextAreaElement) return handleTextAreaKeyDown(e, tree)

    switch (e.code) {
      case "ArrowUp":
        e.shiftKey ?
          selectMultiNode(tree._walker.previousSibling()) :
          selectNode(tree, currentNode, tree._walker.previousNode())
        break
      case "ArrowDown":
        e.shiftKey ?
          selectMultiNode(tree._walker.nextSibling()) :
          selectNode(tree, currentNode, tree._walker.nextNode())
        break
      case "Delete":
        let nextNode =
          findUnselectedNode(() => tree._walker.nextSibling()) ||
          findUnselectedNode(() => tree._walker.previousSibling()) ||
          findUnselectedNode(() => tree._walker.parentNode())

        deleteSelected(tree)
        renderRoot(store)
        selectNode(tree, currentNode, nextNode)
        break
      case "KeyX":
        if (e.metaKey) {
          clearClipboard(tree)

          tree._clipboard = () => selectedGroupedByParent(tree, { ops: ".item-cutting" })
          tree.querySelectorAll("[aria-selected='true']").forEach(a => a.classList.add("item-cutting"))
        }
        break
      case "KeyV":
        const dstSch = getSch(store, tree._walker.currentNode.id)
        if (![RECORD, UNION, TUPLE].includes(dstSch.type)) return

        if (e.metaKey && tree._clipboard) {
          const dstPath = tree._walker.currentNode.id
          const selectedPerParent = tree._clipboard()

          let moved = moveSchs(store, { dstPath, startIndex: 0 }, selectedPerParent)
          renderRoot(store)
          clearClipboard(tree)
          reselectNodes(tree, moved)
        }
        break
      case "Enter":
        let group = currentNode.closest("[role='group']")?.dataset?.group

        if (group == "keyed") {
          getAndUpdateSch(store, (a, m) => m.path == currentNode.id, (a, m) => ({ ...a, uiMode: "editKey" }))
          renderRoot(store)
          tree.querySelector("textarea")?.focus()
        }
        break
      default:
        switch (e.key) {
          case "+":
            let randomSch = schs[ranInt(schs.length)]

            putSchs(store, currentNode.id, [{ k: null, sch: randomSch, index: 0 }])
            renderRoot(store)
            break
        }
    }

    e.preventDefault()
  }

  function handleTreeClick(e) {
    let tree = this
    let prevtNode = tree._walker.currentNode
    tree._walker.currentNode = e.target.closest("[role='treeitem']")
    selectNode(tree, prevtNode, tree._walker.currentNode, { focus: !tree._walker.currentNode.querySelector("textarea") })
  }

  const ranInt = max => Math.floor(Math.random() * Math.floor(max));
  const jEQ = (obj1, obj2) => JSON.stringify(obj1) == JSON.stringify(obj2)

  window.addEventListener("DOMContentLoaded", e => {
    document.querySelectorAll("[role='tree']").forEach(tree => {
      tree._walker = document.createTreeWalker(
        tree,
        NodeFilter.SHOW_ELEMENT,
        {
          acceptNode: function (node) {
            if (node.hasAttribute("aria-selected")) return NodeFilter.FILTER_ACCEPT
            else return NodeFilter.FILTER_SKIP
          }
        },
        false
      )
      tree.onkeydown = handleTreeKeydown
      tree.onclick = handleTreeClick

      let firstNode = tree._walker.nextNode()
      selectNode(tree, firstNode, firstNode)
    })
  })
  renderRoot(store)
</script>

<body>
</body>

</html>
